package com.gentics.dependency.reporting;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Stream;

import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.DefaultProjectBuildingRequest;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.ProjectBuildingRequest;
import org.apache.maven.shared.dependency.graph.DependencyGraphBuilder;
import org.apache.maven.shared.dependency.graph.DependencyGraphBuilderException;
import org.apache.maven.shared.dependency.graph.DependencyNode;
import org.apache.maven.shared.dependency.graph.traversal.DependencyNodeVisitor;

import com.gentics.dependency.reporting.java.model.DependencyInfo;
import com.gentics.dependency.reporting.java.model.DependencyUpdatesReport;
import com.gentics.dependency.reporting.out.model.OutDependency;

/**
 * Reads the <code>reportFile</code>, which is supposed to be an xml file generated by the <code>versions-maven-plugin</code> with the goal <code>dependency-updates-aggregate-report</code>.
 * The report is then transformed into the common format and written as file named <code>outputName</code> in the <code>outputDirectory</code>.
 */
@Mojo(name = "java-transform", defaultPhase = LifecyclePhase.PACKAGE, threadSafe = true)
public class TransformDependencyUpdatesReportMojo extends AbstractOutputMojo {
	/**
	 * The Maven project.
	 */
	@Component
	private MavenProject project;

	/**
	 * The Maven session.
	 */
	@Component
	private MavenSession session;

	/**
	 * The dependency graph builder to use.
	 */
	@Component(hint = "default")
	private DependencyGraphBuilder dependencyGraphBuilder;

	/**
	 * Report file which (xml) which is read and transformed.
	 */
	@Parameter(required = true)
	private File reportFile;

	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		Log log = getLog();
		if (isSkip()) {
			log.info("Skipping the execution.");
			return;
		}

		log.info(String.format("Reading report from %s", reportFile.getAbsolutePath()));

		DependencyUpdatesReport report = readFromXmlFile(reportFile, DependencyUpdatesReport.class);

		log.info(String.format("Report contains %d dependencies and %d managed dependencies", report.getDependencies().size(), report.getDependencyManagements().size()));

		// remove test and provided dependencies
		report.getDependencies().removeIf(dep -> StringUtils.equalsAny(dep.getScope(), "test", "provided"));
		report.getDependencyManagements().removeIf(dep -> StringUtils.equalsAny(dep.getScope(), "test", "provided"));

		// remove ignored dependencies
		report.getDependencies().removeIf(dep -> ignoreDependency(DependencyInfo.getFullName(dep)));
		report.getDependencyManagements().removeIf(dep -> ignoreDependency(DependencyInfo.getFullName(dep)));

		// remove non-project dependencies
		Set<String> projectDependencies = getProjectDependencies();
		report.getDependencies().removeIf(dep -> !projectDependencies.contains((DependencyInfo.getFullName(dep))));
		report.getDependencyManagements().removeIf(dep -> !projectDependencies.contains((DependencyInfo.getFullName(dep))));

		log.info(String.format(
				"Report contains %d dependencies and %d managed dependencies after removing test and ignored dependencies",
				report.getDependencies().size(), report.getDependencyManagements().size()));

		List<OutDependency> dependencies = new ArrayList<>();
		Stream.concat(report.getDependencies().stream(), report.getDependencyManagements().stream()).forEach(info -> {
			String name = DependencyInfo.getFullName(info);
			String current = info.getCurrentVersion();
			String latest = info.getLastVersion();
			String incremental = getLastEntry(info.getIncrementals());
			String minor = getLastEntry(info.getMinors());
			String major = getLastEntry(info.getMajors());
			if (StringUtils.isEmpty(latest)) {
				latest = current;
			}
			dependencies.add(new OutDependency().setName(name).setCurrent(current).setLatest(latest)
					.setIncremental(incremental).setMinor(minor).setMajor(major));
		});

		outputDependencies(dependencies);
	}

	/**
	 * Get the last entry of the given list of strings, or null if the list is empty
	 * @param entries list of strings
	 * @return last entry or null
	 */
	protected String getLastEntry(List<String> entries) {
		if (CollectionUtils.isEmpty(entries)) {
			return null;
		} else {
			return entries.get(entries.size() - 1);
		}
	}

	/**
	 * Get the names of the project dependencies. The names are in the format [groupId]:[artifactId]. Test and provided dependencies are ignored.
	 * @return set of dependency names
	 * @throws MojoExecutionException
	 */
	protected Set<String> getProjectDependencies() throws MojoExecutionException {
		try {
			Set<String> dependencyNames = new HashSet<>();

			ProjectBuildingRequest buildingRequest = new DefaultProjectBuildingRequest(
					session.getProjectBuildingRequest());

			buildingRequest.setProject(project);

			Log log = getLog();
			DependencyNode rootNode = dependencyGraphBuilder.buildDependencyGraph(buildingRequest, art -> {
				log.info(String.format("Found project dependency %s:%s:%s", art.getGroupId(), art.getArtifactId(), art.getScope()));
				return !StringUtils.equalsAny(art.getScope(), "test", "provided");
			});

			DependencyNodeVisitor visitor = new DependencyNodeVisitor() {
				@Override
				public boolean visit(DependencyNode node) {
					Artifact artifact = node.getArtifact();
					dependencyNames.add(String.format("%s:%s", artifact.getGroupId(), artifact.getArtifactId()));
					return true;
				}

				@Override
				public boolean endVisit(DependencyNode node) {
					return true;
				}
			};

			rootNode.accept(visitor);

			return dependencyNames;
		} catch (DependencyGraphBuilderException e) {
			throw new MojoExecutionException("Error while building dependency graph", e);
		}
	}
}
